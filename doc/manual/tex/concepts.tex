% This file is part of xrayutilities.
%
% xrayutilities is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, see <http://www.gnu.org/licenses/>.
%
% Copyright (C) 2009 Eugen Wintersberger <eugen.wintersberger@desy.de>
% Copyright (C) 2010 Dominik Kriegner <dominik.kriegner@aol.at>

%%% basic usage principles of xrutils

This chapter describes two concepts of usage for the {\tt xrutils} package, which help with planning and analyzing experiments.

First the flowchart of how angular coordinates of Bragg reflections are calculated is shown (Fig.~\ref{fig:xrutils_usage_planning}). After that a sketch on how to analyze x-ray diffraction data with {\tt xrutils} is shown in Fig.~\ref{fig:xrutils_usage}. More detailed descriptions of the steps described here given in the subsequent chapters.

\begin{figure}[H]
 \centering
 \includegraphics[width=0.8\linewidth]{pics/xrutils_usage_planning}
 \caption{Flow diagram showing how to calculate angular positions of Bragg reflection using {\tt xrutils}.}
 \label{fig:xrutils_usage_planning}
\end{figure}

\begin{figure}[H]
 \centering
 \includegraphics[width=0.8\linewidth]{pics/xrutils_usage}
 \caption{Flow diagram showing how to analyze x-ray diffraction data using {\tt xrutils}.}
 \label{fig:xrutils_usage}
\end{figure}

\section{Usage examples}

\subsection{spec-file from rotating anode}

The example shows the use of various parts of the xrutils package. It reads a \emph{spec}-file; saves the content into a HDF5 file; reads a particular scan and plots it as reciprocal space map.

\begin{lstlisting}[caption={reading a spec-file, saving it to HDF5, reading a particular scan, convert it to reciprocal space, plot it using matplotlib}]
import xrutils as xu
import numpy
import tables
import matplotlib.pyplot as plt

sample = "ko222"

cch = 501
chpdeg = 250.333
roi=[80,920]

#define substrate material + experimental class
InAs = xu.materials.InAs
expcub = xu.HXRD(InAs.Q(1,1,-2),InAs.Q(1,1,1))

#config psd and initialize a intensity normalizer
expcub.Ang2Q.init_linear('z+',cch,1024.,chpdeg=chpdeg,roi=roi)
RA_normalizer_psd = xu.IntensityNormalizer("MCA",time="Seconds",absfun=lambda d: d["PSDCORR"]/d["PSD"].astype(numpy.float))

# print theoretic angular positions
ang111 = expcub.Q2Ang(InAs.Q(1,1,1))
ang331 = expcub.Q2Ang(InAs.Q(3,3,1))
ang224 = expcub.Q2Ang(InAs.Q(2,2,4))
print " hkl\t%10s\t%10s\t%10s" %("om","tt","phi")
print "-------------------------------------------------------"
print " 111\t %10.3f\t%10.3f\t%10.3f" %(ang111[1],ang111[2],ang111[0])
print " 331\t %10.3f\t%10.3f\t%10.3f" %(ang331[1],ang331[2],ang331[0])
print " 224\t %10.3f\t%10.3f\t%10.3f" %(ang224[1],ang224[2],ang224[0])

#read spec file and save to HDF5
try: s
except NameError: s = xu.io.SPECFile(sample+".spec")
else: s.Update()

h5file = "./data/"+sample+".h5"
try: h5.isopen
except NameError:
    h5 = tables.openFile(h5file,mode='a')
else:
    if not h5.isopen:
        h5 = tables.openFile(h5file,mode='a')
s.Save2HDF5(h5)

# read reciprocal space map from HDF5 file and plot it

uom = 12.7279 # aligned angular positions
utt = 25.4447
[thdel,thom,thtt] = expcub.Q2Ang(InAs.Q(1,1,1))

# parse map from file (omega scan around InAs(111) with PSD)
MAP = numpy.zeros(0)
for i in [17,]:
    exec ("scan = h5.root.%s.scan_%d.data.read()" %(sample,i))
    if MAP.dtype == numpy.float64:  MAP.dtype = scan.dtype
    MAP = numpy.append(MAP,scan)

# normalize intensity and apply region of interests
PSDRAW = RA_normalizer_psd(MAP)
PSD = xu.blockAveragePSD(PSDRAW, 1, roi=roi)
# conversion to reciprocal space
[qx,qy,qz] = expcub.Ang2Q.linear(MAP['Omega'],
                utt*numpy.ones(MAP['Omega'].size),
                delta=[ uom-thom, utt-thtt])

# grid intensity for visualization
gridder = xu.Gridder2D(200,200)
gridder(qy,qz,PSD)

# restrict dynamic range of measurement and make log10
ma = gridder.gdata.max()*10**(-0)
mi = gridder.gdata.max()*10**(-6)
INT = numpy.log10(numpy.minimum(
       numpy.maximum(gridder.gdata.transpose(),mi),ma))

# plot the map
plt.figure(); plt.clf()
cf = plt.contourf(gridder.xaxis, gridder.yaxis, INT,50)
plt.xlabel(r'$Q_y$ ($\AA$)'); plt.ylabel(r'$Q_z$ ($\AA$)')
#plt.subplots_adjust(bottom=0.12, top=0.92)
plt.colorbar(cf,ticks=numpy.arange(INT.min(),INT.max()+.1,
             round((INT.max()-INT.min())/10,1)),format="%.1f")
plt.figtext(0.76,0.93,r"$\log($Int$)$ (cps)")
plt.savefig(sample+"_111rsm.png",dpi=200)

#close HDF5-datafile
h5.close()
\end{lstlisting}
